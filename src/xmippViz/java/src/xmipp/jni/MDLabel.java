package xmipp.jni;

public class MDLabel {
   public static final int MDL_UNDEFINED = -1; /// 
   public static final int MDL_FIRST_LABEL = 0;  /// < The label MDL_OBJID is special and should not be used
   public static final int MDL_OBJID = MDL_FIRST_LABEL;  /// < object id (int), NOTE: This label is special and shouldn't be used
   public static final int MDL_GATHER_ID = 1;  ///  Special label to be used when gathering MDs in MpiMetadataPrograms
   public static final int MDL_ANGLE_PSI = 2;  /// < Psi angle of an image (double,degrees)
   public static final int MDL_ANGLE_PSI2 = 3;  /// < Psi angle of an image (double,degrees)
   public static final int MDL_ANGLE_PSI_DIFF = 4;  /// < difference between psi angles (double,degrees)
   public static final int MDL_ANGLE_ROT = 5;  /// < Rotation angle of an image (double,degrees)
   public static final int MDL_ANGLE_ROT2 = 6;  /// < Rotation angle of an image (double,degrees)
   public static final int MDL_ANGLE_ROT_DIFF = 7;  /// < difference between rot angles (double,degrees)
   public static final int MDL_ANGLE_TILT = 8;  /// < Tilting angle of an image (double,degrees)
   public static final int MDL_ANGLE_TILT2 = 9;  /// < Tilting angle of an image (double,degrees)
   public static final int MDL_ANGLE_TILT_DIFF = 10;  /// < difference between tilt angles (double,degrees)
   public static final int MDL_ANGLE_DIFF0 = 11;  /// < difference between two angles (double,degrees)
   public static final int MDL_ANGLE_DIFF = 12;  /// < difference between two angles (double,degrees)
   public static final int MDL_ANGLE_DIFF2 = 13;  /// < difference between two angles (double,degrees)
   public static final int MDL_ANGLE_Y = 14;    /// < Angle between y-axis and tilt-axis (double, degrees) for untilted micrographs
   public static final int MDL_ANGLE_Y2 = 15;    /// < Angle between y-axis and tilt-axis (double, degrees) for tilted micrographs
   public static final int MDL_ANGLE_TEMPERATURE = 16;  /// < Angular temperature (double,degrees)
   public static final int MDL_APPLY_SHIFT = 17; /// <Apply shift when project the volume ,
   public static final int MDL_AVG = 18;  /// < average value (double)
   public static final int MDL_AVG_CHANGES_ORIENTATIONS = 19;  ///  Average change in angular orientation (double degrees)
   public static final int MDL_AVG_CHANGES_OFFSETS = 20;  ///  Average change in offset (double pixels)
   public static final int MDL_AVG_CHANGES_CLASSES = 21;  ///  Average change in class assignment(double dimensionaless)
   public static final int MDL_AVGPMAX = 22;  /// < Average (per class) of the maximum value of normalized probability function) (double)
   public static final int MDL_BGMEAN = 23;  /// < Mean background value for an image
   public static final int MDL_BLOCK_NUMBER = 24;  /// < Current block number (for incremental EM)
   public static final int MDL_CL2D_CHANGES = 25;  /// < Number of changes between iterations
   public static final int MDL_CL2D_SIMILARITY = 26;  /// < Average cross-correlation for the image (double)
   public static final int MDL_CLASS_COUNT = 27;  /// < Number of images assigned to the same class as this image
   public static final int MDL_CLASS_PERCENTAGE = 28;  /// < Percentage of images assigned to the same class as this image
   public static final int MDL_CLASSIFICATION_DATA = 29;  /// < Data vector for classification (vector double)
   public static final int MDL_CLASSIFICATION_DATA_SIZE = 30;  /// < Size of data vectors for classification (int)
   public static final int MDL_CLASSIFICATION_DPR_05 = 31;  /// < Differential Phase Residual evaluated at FRC=0.5
   public static final int MDL_CLASSIFICATION_INTRACLASS_DISTANCE = 32;  /// < Average intraclass distance (double)
   public static final int MDL_CLASSIFICATION_FRC_05 = 33;  /// < Digital frequency at which the FRC drops below 0.5 (double)
   public static final int MDL_COMMENT = 34;  /// < Serve to make annotations on the metadata row
   public static final int MDL_COORD_CONSENSUS_SCORE = 35;  /// < Store a score for the coords. consensus (it will change the behavoir of the viewer)
   public static final int MDL_COST = 36;  /// < Cost for the image (double)
   public static final int MDL_COST_PERCENTILE = 37;  /// < Cost percentile for the image (double)
   public static final int MDL_COUNT = 38;  /// < Number of elements of a type (int) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_COUNT2 = 39;  /// < Number of elements of a type (int) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_CORR_DENOISED_PROJECTION = 40;  /// <Correlation between the denoised image and the projection proposed
   public static final int MDL_CORR_DENOISED_NOISY = 41;  /// <Correlation between the denoised image and the noisy version
   public static final int MDL_CRYSTAL_CELLX = 42;  /// < Cell location for crystals
   public static final int MDL_CRYSTAL_CELLY = 43;  /// < Cell location for crystals
   public static final int MDL_CRYSTAL_LATTICE_A = 44;    ///  < Lattice vector for projection (vector double)
   public static final int MDL_CRYSTAL_LATTICE_B = 45;    ///  < Lattice vector for projection (vector double)
   public static final int MDL_CRYSTAL_DISAPPEAR_THRE = 46;    ///  < Disappearing threshold (double)
   public static final int MDL_CRYSTAL_SHFILE = 47;    ///  < Shift file for crystal projection
   public static final int MDL_CRYSTAL_ORTHO_PRJ = 48;    ///  <Orthogonal projection or not (bool)
   public static final int MDL_CRYSTAL_PROJ = 49;    ///  < Have a crystal projection (bool)
   public static final int MDL_CRYSTAL_SHIFTX = 50;  /// < Shift for the image in the X axis (double) for crystals
   public static final int MDL_CRYSTAL_SHIFTY = 51;  /// < Shift for the image in the Y axis (double) for crystals
   public static final int MDL_CRYSTAL_SHIFTZ = 52;  /// < Shift for the image in the Z axis (double) for crystals
   public static final int MDL_CRYSTAL_NOISE_SHIFT  = 53;  /// < noise if center of unit cell (vector double)
   public static final int MDL_CONTINUOUS_X = 54;  /// < X shift of continuous assignment
   public static final int MDL_CONTINUOUS_Y = 55;  /// < Y shift of continuous assignment
   public static final int MDL_CONTINUOUS_FLIP = 56;  /// < Flip of continuous assignment
   public static final int MDL_CONTINUOUS_GRAY_A = 57;  /// < a value of continuous assignment
   public static final int MDL_CONTINUOUS_GRAY_B = 58;  /// < b value of continuous assignment
   public static final int MDL_CONTINUOUS_SCALE_ANGLE = 59;  /// < scale angle of continuous assignment
   public static final int MDL_CONTINUOUS_SCALE_X = 60;  /// < scale x of continuous assignment
   public static final int MDL_CONTINUOUS_SCALE_Y = 61;  /// < scale y of continuous assignment
   public static final int MDL_CORRELATION_IDX = 62;  /// < correlation value between a particle and its assigned projection
   public static final int MDL_CORRELATION_MASK = 63;  /// < masked correlation value between a particle and its assigned projection inside the region with pixel values higher than the standard deviation
   public static final int MDL_CORRELATION_WEIGHT = 64;  /// < weighted correlation value between a particle and its assigned projection taking into the difference between both images
   public static final int MDL_CTF_DATA_PHASE_FLIPPED = 65; // Is the Data Phase-Flippled? /// 
   public static final int MDL_CTF_CORRECTED = 66; // Is the CTF corrected? /// 
   public static final int MDL_CTF_INPUTPARAMS = 67;  /// < Parameters file for the CTF Model (std::string)
   public static final int MDL_CTF_MODEL = 68;  /// < Name for the CTF Model (std::string)
   public static final int MDL_CTF_MODEL2 = 69;  /// < Name for another CTF model (std::string)
   public static final int MDL_CTF_SAMPLING_RATE = 70;  /// < Sampling rate
   public static final int MDL_CTF_SAMPLING_RATE_Z = 71;  /// < Sampling rate in Z direction
   public static final int MDL_CTF_VOLTAGE = 72;  /// < Microscope voltage (kV)
   public static final int MDL_CTF_DEFOCUSA = 73;  /// < average defocus (Angtroms)
   public static final int MDL_CTF_DEFOCUSU = 74;  /// < Defocus U (Angstroms)
   public static final int MDL_CTF_DEFOCUSV = 75;  /// < Defocus V (Angstroms)
   public static final int MDL_CTF_DEFOCUS_CHANGE = 76;  /// < Defocus change with respect to previous defoucs (Angstroms)
   public static final int MDL_CTF_DEFOCUS_R2 = 77;  /// < Defocus coefficient of determination
   public static final int MDL_CTF_DEFOCUS_COEFS = 78;  /// < Coefficients of the defocus adjustment plane
   public static final int MDL_CTF_DEFOCUS_RESIDUAL = 79;  /// < Difference between the observed defocus value and the estimated defocus value
   public static final int MDL_CTF_X0 = 80;  /// < The CTF is valid within (x0,y0) to (xF,yF) in the micrograph coordinates
   public static final int MDL_CTF_Y0 = 81;  /// < The CTF is valid within (x0,y0) to (xF,yF) in the micrograph coordinates
   public static final int MDL_CTF_XF = 82;  /// < The CTF is valid within (x0,y0) to (xF,yF) in the micrograph coordinates
   public static final int MDL_CTF_YF = 83;  /// < The CTF is valid within (x0,y0) to (xF,yF) in the micrograph coordinates
   public static final int MDL_CTF_DEFOCUS_PLANEUA = 84;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEUB = 85;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEUC = 86;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEVA = 87;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEVB = 88;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEVC = 89;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_ANGLE = 90;  /// < Defocus angle (degrees)
   public static final int MDL_CTF_CS = 91;  /// < Spherical aberration
   public static final int MDL_CTF_CA = 92;  /// < Chromatic aberration
   public static final int MDL_CTF_GROUP = 93;  /// < group images by defocus
   public static final int MDL_CTF_ENERGY_LOSS = 94;  /// < Energy loss
   public static final int MDL_CTF_ENVELOPE = 95; //<Envelope function /// 
   public static final int MDL_CTF_ENVELOPE_PLOT = 96; //<Envelope function /// 
   public static final int MDL_CTF_LENS_STABILITY = 97;  /// < Lens stability
   public static final int MDL_CTF_CONVERGENCE_CONE = 98;  /// < Convergence cone
   public static final int MDL_CTF_LONGITUDINAL_DISPLACEMENT = 99;  /// < Longitudinal displacement
   public static final int MDL_CTF_TRANSVERSAL_DISPLACEMENT = 100;  /// < Transversal displacemente
   public static final int MDL_CTF_Q0 = 101;  /// < Inelastic absorption
   public static final int MDL_CTF_K = 102;  /// < CTF gain
   public static final int MDL_CTF_ENV_R0 = 103;  /// < CTF Envelope polynomial parameter
   public static final int MDL_CTF_ENV_R1 = 104;  /// < CTF Envelope polynomial parameter
   public static final int MDL_CTF_ENV_R2 = 105;  /// < CTF Envelope polynomial parameter
   public static final int MDL_CTF_BG_GAUSSIAN_K = 106;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_SIGMAU = 107;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_SIGMAV = 108;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_CU = 109;  /// <CTF_ CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_CV = 110;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_ANGLE = 111;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_SQRT_K = 112;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_SQRT_U = 113;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_SQRT_V = 114;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_SQRT_ANGLE = 115;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_BASELINE = 116;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_K = 117;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_SIGMAU = 118;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_SIGMAV = 119;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_CU = 120;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_CV = 121;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_ANGLE = 122;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_R1 = 123;  /// < CTF Background polynomial parameter
   public static final int MDL_CTF_BG_R2 = 124;  /// < CTF Background polynomial parameter
   public static final int MDL_CTF_BG_R3 = 125;  /// < CTF Background polynomial parameter
   public static final int MDL_CTF_CRIT_NONASTIGMATICVALIDITY = 126;  /// < Maximum frequency (in Angstroms) at which non-astigmatic CTF correction is valid
   public static final int MDL_CTF_CRIT_PSDCORRELATION90 = 127;  /// < PSD correlation at 90 degrees
   public static final int MDL_CTF_CRIT_FIRSTZERORATIO = 128;  /// < First zero ratio
   public static final int MDL_CTF_CRIT_FIRSTMINIMUM_FIRSTZERO_RATIO = 129;  /// < Ratio sigma(firstMinimum)/sigma(firstZero)
   public static final int MDL_CTF_CRIT_FIRSTMINIMUM_FIRSTZERO_DIFF_RATIO = 130;  /// < Ratio sigma(firstMinimum-firstZero)/sigma(firstZero)
   public static final int MDL_CTF_CRIT_FIRSTZEROAVG = 131;  /// < First zero average (in Angstroms)
   public static final int MDL_CTF_CRIT_FIRSTZERODISAGREEMENT = 132;  /// < First zero disagreement with second model (in Angstroms)
   public static final int MDL_CTF_CRIT_MAXFREQ = 133;  /// < Maximum frequency at which the envelope drops below 0.1 (in Angstroms)
   public static final int MDL_CTF_CRIT_DAMPING = 134;  /// < Minimum damping at border
   public static final int MDL_CTF_CRIT_PSDRADIALINTEGRAL = 135;  /// < Integral of the radial PSD
   public static final int MDL_CTF_CRIT_FITTINGSCORE = 136;  /// < Score of the fitting
   public static final int MDL_CTF_CRIT_FITTINGCORR13 = 137;  /// < Correlation between the 1st and 3rd ring of the CTF
   public static final int MDL_CTF_CRIT_PSDVARIANCE = 138;  /// < PSD variance
   public static final int MDL_CTF_CRIT_PSDPCA1VARIANCE = 139;  /// < Variance in the first principal component of the PSDs
   public static final int MDL_CTF_CRIT_PSDPCARUNSTEST = 140;  /// < Runs test on the projection of the PSD on the first principal component
   public static final int MDL_CTF_CRIT_NORMALITY = 141;  /// < Normality test between histogram of micrography and gaussian distribution
   public static final int MDL_CTF_CRIT_ICENESS = 142;  /// < Iceness of the micrograph
   public static final int MDL_CTF_DOWNSAMPLE_PERFORMED = 143;  /// < Downsampling performed to estimate the CTF
   public static final int MDL_CTF_DIMENSIONS = 144; // Size in pixels of the 3D PSF to be created (Xdim = 144; Ydim = 144; Zdim) /// 
   public static final int MDL_CTF_LAMBDA = 145;  ///  Wavelength (nm)
   public static final int MDL_CTF_XRAY_LENS_TYPE = 146;  /// Algorithm used to generate Xray PSF
   public static final int MDL_CTF_XRAY_OUTER_ZONE_WIDTH = 147;  ///  Outermost zone width of the X-ray Fresnel lens (nm)
   public static final int MDL_CTF_XRAY_ZONES_NUMBER = 148; // Number of zones of the X-ray Fresnel lens /// 
   public static final int MDL_CTF_PHASE_SHIFT = 149;	//Volta Phase Plate phase shift /// 
   public static final int MDL_CTF_VPP_RADIUS = 150;    //Phase Plate radius /// 
   public static final int MDL_CUMULATIVE_SSNR = 151;  /// <Cumulative SSNR (double)
   public static final int MDL_DATATYPE = 152;  /// < if read from file original image datatype, this is an struct defined in image
   public static final int MDL_DEFGROUP = 153;  /// < Defocus group
   public static final int MDL_DIMRED = 154;  /// < Projection onto a reduced manifold (vector double)
   public static final int MDL_DIRECTION = 155;  /// < Direction in 3D
   public static final int MDL_DM3_IDTAG = 156; /// 
   public static final int MDL_DM3_NODEID = 157; /// 
   public static final int MDL_DM3_NUMBER_TYPE = 158; /// 
   public static final int MDL_DM3_PARENTID = 159; /// 
   public static final int MDL_DM3_TAGCLASS = 160; /// 
   public static final int MDL_DM3_TAGNAME = 161; /// 
   public static final int MDL_DM3_SIZE = 162; /// 
   public static final int MDL_DM3_VALUE = 163; /// 
   public static final int MDL_ENABLED = 164;  /// < Is this image enabled? (int [-1 or 1])
   public static final int MDL_DATE = 165;// < timestamp (string) /// 
   public static final int MDL_TIME = 166;// <  time in seconds (double) /// 
   public static final int MDL_FLIP = 167;  /// < Flip the image? (bool)
   public static final int MDL_FOM = 168;  /// < Figure of Merit in 0-1 range (double)
   public static final int MDL_FRAME_ID = 169;  /// < Unique id of frame inside a Movie
   public static final int MDL_IDX = 170;  /// < Index within a list (size_t)
   public static final int MDL_IMAGE = 171;  /// < Name of an image (std::string)
   public static final int MDL_IMAGE_COVARIANCE = 172;  /// < Name of the covariance imagee associated to this image
   public static final int MDL_IMAGE_IDX = 173;  /// < Index of an image within a list (size_t)
   public static final int MDL_IMAGE_ORIGINAL = 174;  /// < Name of an image from which MDL_IMAGE is coming from
   public static final int MDL_IMAGE_REF = 175;  /// < Name of of the class image from which MDL_IMAGE is coming from
   public static final int MDL_IMAGE_RESIDUAL = 176;  /// < Name of a residual image associated to this image
   public static final int MDL_IMAGE_TILTED = 177;  /// < Name of the tilted images associated to MDL_IMAGE
   public static final int MDL_IMED = 178;  /// < imed value between a particle and its assigned projection
   public static final int MDL_IMGMD = 179;  /// < Name of Metadata file for all images (string)
   public static final int MDL_IMAGE1 = 180;  /// < Image associated to this object (std::string)
   public static final int MDL_IMAGE2 = 181;  /// < Image associated to this object (std::string)
   public static final int MDL_IMAGE3 = 182;  /// < Image associated to this object (std::string)
   public static final int MDL_IMAGE4 = 183;  /// < Image associated to this object (std::string)
   public static final int MDL_IMAGE5 = 184;  /// < Image associated to this object (std::string)
   public static final int MDL_INTSCALE = 185;  /// < Intensity scale for an image
   public static final int MDL_ITEM_ID = 186;  /// < Unique identifier for items inside a list or set (std::size_t)
   public static final int MDL_ITER = 187;  /// < Current iteration number (int)
   public static final int MDL_KERDENSOM_FUNCTIONAL = 188;  /// < Functional value (double)
   public static final int MDL_KERDENSOM_REGULARIZATION = 189;  /// < Regularization value (double)
   public static final int MDL_KERDENSOM_SIGMA = 190;  /// < Sigma value (double)
   public static final int MDL_KEYWORDS = 191;  /// < Keywords associated to this line, should be a single string block (do not use spaces as separators)
   public static final int MDL_KMEANS2D_CENTROID = 192;  /// < Centroid of a cluster for the KMEANS2D classification
   public static final int MDL_KSTEST = 193;  /// <KS-test statistics
   public static final int MDL_LL = 194;  /// < contribution of an image to log-likelihood value
   public static final int MDL_LOCAL_ALIGNMENT_PATCHES = 195;  /// < Two values representing number of patches used for local alignment (X, Y)
   public static final int MDL_LOCAL_ALIGNMENT_COEFFS_X = 196;  /// < BSpline coefficient in X dim
   public static final int MDL_LOCAL_ALIGNMENT_COEFFS_Y = 197;  /// < BSpline coefficient in Y dim
   public static final int MDL_LOCAL_ALIGNMENT_CONF_2_5_PERC = 198;  /// < A shift amount at confidence level of 2.5%
   public static final int MDL_LOCAL_ALIGNMENT_CONF_97_5_PERC = 199;  /// < A shift amount at confidence level of 95.5%
   public static final int MDL_LOCAL_ALIGNMENT_CONTROL_POINTS = 200;  /// < Three values representing number of control points used for local alignment (X, Y, N)
   public static final int MDL_MAGNIFICATION = 201;  ///  Magnification of microscope
   public static final int MDL_MAPTOPOLOGY = 202;  /// < Map topology (KerDenSOM, ...)
   public static final int MDL_MASK = 203;  /// < Name of a mask associated to image
   public static final int MDL_MAXCC = 204;  /// < Maximum cross-correlation for the image (double)
   public static final int MDL_MAXCC_PERCENTILE = 205;  /// < Percentile of the maximum cross-correlation for the image (double)
   public static final int MDL_MAX = 206;  /// < Maximum value (double)
   public static final int MDL_MICROGRAPH = 207;  /// < Name of a micrograph (std::string)
   public static final int MDL_MICROGRAPH_ID = 208;  /// < Micrograph unique id for reference (MDL_ITEM_ID should be used for Micrographs list)
   public static final int MDL_MICROGRAPH_MOVIE = 209;  /// < Name of a movie (std::string)
   public static final int MDL_MICROGRAPH_MOVIE_ID = 210;  /// < Unique identifier of a movie.
   public static final int MDL_MICROGRAPH_PARTICLES = 211;  /// < Name of a position file (std::string)
   public static final int MDL_MICROGRAPH_ORIGINAL = 212;  /// < Name of the original micrograph, MDL_MICROGRAPH is probably a downsampled version of this one (std::string)
   public static final int MDL_MICROGRAPH_TILTED = 213;  /// < Name of the corresponding tilted micrograph (std::string)
   public static final int MDL_MICROGRAPH_TILTED_ORIGINAL = 214;  /// < Name of the corresponding original, tilted micrograph (std::string)
   public static final int MDL_MIN = 215;  /// < Minimum value (double)
   public static final int MDL_MIRRORFRAC = 216;  /// < Mirror fraction for a Maximum Likelihood model
   public static final int MDL_MISSINGREGION_NR = 217;  /// < Number of missing region in subtomogram
   public static final int MDL_MISSINGREGION_TYPE = 218;  /// < Type of missing region in subtomogram
   public static final int MDL_MISSINGREGION_THY0 = 219;  /// < Initial tilt angle in Y for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THYF = 220;  /// < Final tilt angle in Y for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THX0 = 221;  /// < Initial tilt angle in X for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THXF = 222;  /// < Final tilt angle in X for missing region in subtomogram
   public static final int MDL_MLF_CTF = 223;     /// < MLF CTF estimated value (double)
   public static final int MDL_MLF_WIENER = 224;  /// < MLF Wiener filter (double)
   public static final int MDL_MLF_SIGNAL = 225;  /// < MLF signal (double)
   public static final int MDL_MLF_NOISE = 226;   /// < MLF Wiener filter (double)
   public static final int MDL_MODELFRAC = 227;  /// < Model fraction (alpha_k) for a Maximum Likelihood model
   public static final int MDL_NEIGHBORS = 228;  /// < Vector of indexes to points some "neighbors"
   public static final int MDL_NEIGHBOR = 229;  /// < Particular neighbor (pointed myNEIGHBORS)
   public static final int MDL_NEIGHBORHOOD_RADIUS = 230;  /// < Radius of the neighborhood (radians)
   public static final int MDL_NMA = 231;  /// < Normal mode displacements (vector double)
   public static final int MDL_NMA_COLLECTIVITY = 232;  /// < NMA Collectivity of a given mode
   public static final int MDL_NMA_ATOMSHIFT = 233;  /// < NMA Atom shift in Angstroms
   public static final int MDL_NMA_ENERGY = 234;  /// < NMA energy contained in the NMA displacement vector
   public static final int MDL_NMA_MINRANGE = 235;  /// < Minimum value observed for a given NMA mode
   public static final int MDL_NMA_MAXRANGE = 236;  /// < Maximum value observed for a given NMA mode
   public static final int MDL_NMA_MODEFILE = 237;  /// < File with an NMA mode
   public static final int MDL_NMA_SCORE = 238;  /// < NMA Score of a given mode
   public static final int MDL_NOISE_ANGLES = 239;  /// < Noise description for projected angles
   public static final int MDL_NOISE_PARTICLE_COORD = 240;  /// < Noise description for particle's center coordenates (when projecting)
   public static final int MDL_NOISE_COORD = 241;  //Use instead of MDL_NOISE_PARTICLE_COORD in future /// 
   public static final int MDL_NOISE_PIXEL_LEVEL = 242;  /// < Noise description for pixels' gray level (when projecting)
   public static final int MDL_ORDER = 243;  ///  auxiliary label to be used as an index (long)
   public static final int MDL_ORIGIN_X = 244;  /// < Origin for the image in the X axis (double)
   public static final int MDL_ORIGIN_Y = 245;  /// < Origin for the image in the Y axis (double)
   public static final int MDL_ORIGIN_Z = 246;  /// < Origin for the image in the Z axis (double)
   public static final int MDL_OPTICALFLOW_MEANX = 247;  /// <Mean of the movement in x direction of the motion map> (double)
   public static final int MDL_OPTICALFLOW_MEANY = 248;  /// <Mean of the movement in y direction of the motion map> (double)
   public static final int MDL_OPTICALFLOW_STDX = 249;  /// <Standatd deviation of the movement in x direction of the motion map> (double)
   public static final int MDL_OPTICALFLOW_STDY = 250;  /// <Standard deviation of the movement in y direction of the motion map> (double)
   public static final int MDL_PARTICLE_ID = 251;  /// < Particle unique identifier for reference. (The MDL_ITEM_ID should be used when particle list)
   public static final int MDL_PHANTOM_BGDENSITY = 252;  /// < Phantom background density (double)
   public static final int MDL_PHANTOM_FEATURE_CENTER = 253;  /// < Center of the feature (vector double)
   public static final int MDL_PHANTOM_FEATURE_DENSITY = 254;  /// < The density of the feature (double)
   public static final int MDL_PHANTOM_FEATURE_OPERATION = 255;  /// < Operation in case of overlapping features (+,-)
   public static final int MDL_PHANTOM_FEATURE_SPECIFIC = 256;  /// < Specific parameters for a feature (vector double)
   public static final int MDL_PHANTOM_FEATURE_TYPE = 257;  /// < Type of the feature (Sphere, Blob, ...) (std::string)
   public static final int MDL_PHANTOM_SCALE = 258;  /// < Number which will multiply all features (double)
   public static final int MDL_MACRO_CMD = 259; //ImageJ macro command on picker /// 
   public static final int MDL_MACRO_CMD_ARGS = 260; //ImageJ macro args on picker /// 
   public static final int MDL_COLOR = 261;  /// < Color for particle picking
   public static final int MDL_PICKING_TEMPLATES = 262;  /// < Number of templates
   public static final int MDL_PICKING_STATE = 263;  /// < State for particle picking
   public static final int MDL_PICKING_MICROGRAPH_STATE = 264;  /// < Micrograph state for particle picking
   public static final int MDL_PICKING_AUTOPICKPERCENT = 265; /// 
   public static final int MDL_PICKING_PARTICLE_SIZE = 266;  /// < Particle size for particle picking
   public static final int MDL_PICKING_AUTOPARTICLES_SIZE = 267;  /// < Number of automatic particles picked
   public static final int MDL_PICKING_MANUALPARTICLES_SIZE = 268;  /// < Number of manual particles picked
   public static final int MDL_PMAX = 269;  /// < Maximum value of normalized probability function (now called "Pmax/sumP") (double)
   public static final int MDL_POINTSASYMETRICUNIT = 270;  ///  < Number of non-redundant projections directions (size_t)
   public static final int MDL_PRJ_DIMENSIONS = 271; // X = 271;Y dimensions for the generated projections /// 
   public static final int MDL_PRJ_ANGFILE = 272;   /// < File for generated angles
   public static final int MDL_PRJ_PSI_NOISE = 273;   ///  < Psi angle dev and mean noise (vector double)
   public static final int MDL_PRJ_PSI_RANDSTR = 274;  ///  < Type of randomness for Psi (std::string)
   public static final int MDL_PRJ_PSI_RANGE = 275;   ///  < Psi angle range (vector double)
   public static final int MDL_PRJ_ROT_NOISE  = 276;   ///  < Rotational angle dev and mean noise (vector double)
   public static final int MDL_PRJ_ROT_RANDSTR = 277;   ///  < Type of randomness for Rotational (std::string)
   public static final int MDL_PRJ_ROT_RANGE = 278; /// 
   public static final int MDL_PRJ_TILT_NOISE = 279;   ///  < Tilt angle dev and mean noise (vector double)
   public static final int MDL_PRJ_TILT_RANDSTR = 280;   ///  < Type of randomness for Tilt (std::string)
   public static final int MDL_PRJ_TILT_RANGE = 281; // Vector with the initial and final tilt angle values = 281; and step size /// 
   public static final int MDL_PRJ_VOL = 282;        // Volume file name to generate projections from /// 
   public static final int MDL_PROGRAM = 283;// <  program name /// 
   public static final int MDL_USER = 284;// <  user name /// 
   public static final int MDL_DIMENSIONS_3D = 285;  // X = 285;Y = 285;Z dimensions /// 
   public static final int MDL_DIMENSIONS_2D = 286;  // X = 286;Y dimensions /// 
   public static final int MDL_PSD = 287;  /// < A Power Spectrum Density file name (std::string)
   public static final int MDL_PSD_ENHANCED = 288;  /// < A enhanced Power Spectrum Density file name (std::string)
   public static final int MDL_RANDOMSEED = 289;  /// < Seed for random number generator
   public static final int MDL_REF3D = 290;  /// < 3D Class to which the image belongs (int)
   public static final int MDL_REF = 291;  /// < Class to which the image belongs (int)
   public static final int MDL_REF2 = 292;  /// < Store a second class (int)
   public static final int MDL_REFMD = 293;  /// < Name of Metadata file for all references(string)
   public static final int MDL_RESOLUTION_DPR = 294;  /// <differential phase residual (double)
   public static final int MDL_RESOLUTION_ERRORL2 = 295;  /// <Error in l2 (double)
   public static final int MDL_RESOLUTION_FRC = 296;  /// <Fourier shell correlation (double)
   public static final int MDL_RESOLUTION_FRCRANDOMNOISE = 297;  /// <Fourier shell correlation noise (double)
   public static final int MDL_RESOLUTION_FREQ = 298;  /// <Frequency in 1/A (double)
   public static final int MDL_RESOLUTION_FREQ2 = 299;  /// < Frequency in 1/A squared (double)
   public static final int MDL_RESOLUTION_FREQREAL = 300;  /// < Frequency in A (double)
   public static final int MDL_RESOLUTION_LOG_STRUCTURE_FACTOR = 301;  /// <Logarithm of the structure factor
   public static final int MDL_RESOLUTION_SSNR = 302;  /// <Fourier shell correlation (double)
   public static final int MDL_RESOLUTION_STRUCTURE_FACTOR = 303;  /// <Structure factor
   public static final int MDL_RESOLUTION_RFACTOR = 304;  ///  rfactor
   public static final int MDL_SAMPLINGRATE = 305;  /// < sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATE_ORIGINAL = 306;  /// < original sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATE_X = 307;  /// < sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATE_Y = 308;  /// < sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATE_Z = 309;  /// < sampling rate in A/pixel (double)
   public static final int MDL_SCALE = 310;  /// < scaling factor for an image or volume (double)
   public static final int MDL_SCORE_BY_PCA_RESIDUAL_PROJ = 311; /// 
   public static final int MDL_SCORE_BY_PCA_RESIDUAL_EXP = 312; /// 
   public static final int MDL_SCORE_BY_PCA_RESIDUAL = 313; /// 
   public static final int MDL_SCORE_BY_ALIGNABILITY = 314;  /// < score by alignability (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_PRECISION = 315;  /// < score by alignability (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_ACCURACY = 316;  /// < score by alignability (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_PRECISION_EXP = 317;  /// < score by alignability experimental particles (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_PRECISION_REF = 318;  /// < score by alignability references (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_ACCURACY_EXP = 319;  /// < score by alignability experimental particles (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_ACCURACY_REF = 320;  /// < score by alignability references (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_NOISE = 321;  /// < score by alignability noise (double)
   public static final int MDL_SCORE_BY_EMPTINESS = 322;  /// < Small values represent worse particles. Much larger than 1 for good particles
   public static final int MDL_SCORE_BY_ENTROPY = 323;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_GRANULO = 324;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_HISTDIST = 325;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_LBP = 326;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_MIRROR = 327;  /// < score by mirror (double)
   public static final int MDL_SCORE_BY_RAMP = 328;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_SCREENING = 329;  /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_VARIANCE = 330;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_VAR = 331;  ///  < Particle variance (double)
   public static final int MDL_SCORE_BY_GINI = 332;  ///  < Micrographs Gini Coeff. (double)
   public static final int MDL_SCORE_BY_ZERNIKE = 333;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_ZSCORE = 334; /// 
   public static final int MDL_SELFILE = 335;  /// < Name of an image (std::string)
   public static final int MDL_SERIE = 336;  /// < A collection of micrographs, e.g. a tilt serie (std::string)
   public static final int MDL_SHIFT_X = 337;  /// < Shift for the image in the X axis (double)
   public static final int MDL_SHIFT_X2 = 338;  /// < Shift for the image in the X axis (double)
   public static final int MDL_SHIFT_X_DIFF = 339;  /// < difference in Shift along X axis (double)
   public static final int MDL_SHIFT_Y = 340;  /// < Shift for the image in the Y axis (double)
   public static final int MDL_SHIFT_Y2 = 341;  /// < Shift for the image in the Y axis (double)
   public static final int MDL_SHIFT_Y_DIFF = 342;  /// < difference in Shift along  Y axis (double)
   public static final int MDL_SHIFT_Z = 343;  /// < Shift for the image in the Z axis (double)
   public static final int MDL_SHIFT_DIFF0 = 344;  /// < shift difference (double)
   public static final int MDL_SHIFT_DIFF = 345;  /// < shift difference (double)
   public static final int MDL_SHIFT_DIFF2 = 346;  /// < shift difference (double)
   public static final int MDL_SIGMANOISE = 347;  /// < Standard deviation of the noise in ML model
   public static final int MDL_SIGMAOFFSET = 348;  /// < Standard deviation of the offsets in ML model
   public static final int MDL_SIGNALCHANGE = 349;  /// < Signal change for an image
   public static final int MDL_SPH_COEFFICIENTS = 350;  /// < Deformation coefficients
   public static final int MDL_SPH_DEFORMATION = 351;  /// < Deformation in voxels
   public static final int MDL_SPH_TSNE_COEFF1D = 352;  /// tsne coefficicient in 1D
   public static final int MDL_SPH_TSNE_COEFF2D = 353;  /// tsne coefficients in 2D
   public static final int MDL_STDDEV = 354;  /// <stdandard deviation value (double)
   public static final int MDL_STAR_COMMENT = 355;  /// < A comment for this object /*** NOTE THIS IS A SPECIAL CASE AND SO IS TREATED ***/
   public static final int MDL_SUM = 356;  /// < Sum of elements of a given type (double) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_SUMWEIGHT = 357;  /// < Sum of all weights in ML model
   public static final int MDL_SYMNO = 358;  /// < Symmetry number for a projection (used in ART)
   public static final int MDL_TOMOGRAM_VOLUME = 359;  /// < Name for the reconstructed tomogram volume (std::string)
   public static final int MDL_TOMOGRAMMD = 360;  /// < Name for a Metadata file (std::string)
   public static final int MDL_TRANSFORM_MATRIX = 361;  /// < transformation matrix in numpy string format or space separated (std::string)
   public static final int MDL_TEST_SIZE = 362;// < number of test assigned to a program /// 
   public static final int MDL_VOLUME_SCORE_SUM = 363;  ///  < Score corresponding to the sum of cc with cc>threshold
   public static final int MDL_VOLUME_SCORE_SUM_TH = 364;  /// < Score corresponding to the sum of cc-threshold with cc>threshold
   public static final int MDL_VOLUME_SCORE_MEAN = 365;  /// < Score corresponding to the mean of cc with cc>threshold
   public static final int MDL_VOLUME_SCORE_MIN = 366;  /// < Score corresponding to the min of cc with cc>threshold
   public static final int MDL_VOLUME_SCORE1 = 367; ///  < Score 1 for volumes
   public static final int MDL_VOLUME_SCORE2 = 368; ///  < Score 2 for volumes
   public static final int MDL_VOLUME_SCORE3 = 369; ///  < Score 3 for volumes
   public static final int MDL_VOLUME_SCORE4 = 370; ///  < Score 4 for volumes
   public static final int MDL_WEIGHT = 371;  /// < Weight assigned to the image (double)
   public static final int MDL_WEIGHT_P = 372;  /// < Weight assigned to the image accordint to its clusterability with a significance with respect noise (double)
   public static final int MDL_WEIGHT_CONTINUOUS2 = 373;  /// < Weight due to angular continuous assignment
   public static final int MDL_WEIGHT_JUMPER0 = 374;  /// < Weight due to angular jumping
   public static final int MDL_WEIGHT_JUMPER = 375;  /// < Weight due to angular jumping
   public static final int MDL_WEIGHT_JUMPER2 = 376;  /// < Weight due to angular jumping
   public static final int MDL_WEIGHT_SIGNIFICANT = 377;  /// < Weight due to Angular significance
   public static final int MDL_WEIGHT_SSNR = 378;  /// < Weight due to SSNR
   public static final int MDL_WEIGHT_PRECISION_ALIGNABILITY = 379;  /// < Weight due to Alignability Precision
   public static final int MDL_WEIGHT_ALIGNABILITY = 380;  /// < Weight due to Alignability Precision and Accuracy
   public static final int MDL_WEIGHT_ACCURACY_ALIGNABILITY = 381;  /// < Weight due to Alignability Accuracy
   public static final int MDL_WEIGHT_PRECISION_MIRROR = 382;  /// < Weight due to Mirror Precision
   public static final int MDL_WROBUST = 383;  /// < Weight of t-student distribution in robust Maximum likelihood
   public static final int MDL_X = 384;  /// < X component (double)
   public static final int MDL_XCOOR = 385;  /// < X component (int)
   public static final int MDL_XCOOR_TILT = 386;  /// < X component in tilted micrograph (int)
   public static final int MDL_XSIZE = 387;  /// < X size (int)
   public static final int MDL_Y = 388;  /// < Y component (double)
   public static final int MDL_YCOOR = 389;  /// < Y component (int)
   public static final int MDL_YCOOR_TILT = 390;  /// < Y component in tilted micrograph (int)
   public static final int MDL_YSIZE = 391;  /// < Y size (int)
   public static final int MDL_Z = 392;  /// < Z component (double)
   public static final int MDL_ZCOOR = 393;  /// < Z component (int)
   public static final int MDL_ZSCORE = 394;  /// < Global Z Score (double)
   public static final int MDL_ZSCORE_DEEPLEARNING1 = 395;  /// < Z Score (double)
   public static final int MDL_GOOD_REGION_SCORE = 396;  /// < Z Score (double)
   public static final int MDL_ZSCORE_HISTOGRAM = 397;  /// < Z Score (double)
   public static final int MDL_ZSCORE_RESMEAN = 398;  /// < Z Score of the mean of the residuals (double)
   public static final int MDL_ZSCORE_RESVAR = 399;  /// < Z Score of the stddev of the residuals (double)
   public static final int MDL_ZSCORE_RESCOV = 400;  /// < Z Score of the covariance matrix of the residuals (double)
   public static final int MDL_ZSCORE_SHAPE1 = 401;  /// < Z Score (double)
   public static final int MDL_ZSCORE_SHAPE2 = 402;  /// < Z Score (double)
   public static final int MDL_ZSCORE_SNR1 = 403;  /// < Z Score (double)
   public static final int MDL_ZSCORE_SNR2 = 404;  /// < Z Score (double)
   public static final int MDL_ZSIZE = 405;  /// < Z size (int)
   public static final int RLN_AREA_ID = 406;  /// < ID for the area (or field of view). If one does not use (tilt) series, area would be the same as micrograph...
   public static final int RLN_AREA_NAME = 407;  /// < Name for the area (or field of view). If one does not use (tilt) series, area would be the same as micrograph...
   public static final int RLN_COMMENT = 408; // The RLN_COMMENT is handled specially as well /// 
   public static final int RLN_CTF_BFACTOR = 409;  /// < B-factor
   public static final int RLN_CTF_SCALEFACTOR = 410;  /// < linear scale-factor
   public static final int RLN_CTF_SAMPLING_RATE = 411;  /// < Sampling rate
   public static final int RLN_CTF_VOLTAGE = 412;  /// < Microscope voltage (kV)
   public static final int RLN_CTF_DEFOCUSU = 413;  /// < Defocus U (Angstroms)
   public static final int RLN_CTF_DEFOCUSV = 414;  /// < Defocus V (Angstroms)
   public static final int RLN_CTF_DEFOCUS_ANGLE = 415;  /// < Defocus angle (degrees)
   public static final int RLN_CTF_CS = 416;  /// < Spherical aberration
   public static final int RLN_CTF_CA = 417;  /// < Chromatic aberration
   public static final int RLN_CTF_DETECTOR_PIXEL_SIZE = 418;  /// < Pixel size for detector as used in CTF-determination
   public static final int RLN_CTF_ENERGY_LOSS = 419;  /// < Energy loss
   public static final int RLN_CTF_FOM = 420;  /// < ctffind3 FOM (CC) for quality of CTF-fit
   public static final int RLN_CTF_IMAGE = 421;  /// < name of an image describing the CTF model
   public static final int RLN_CTF_LENS_STABILITY = 422;  /// < Lens stability
   public static final int RLN_CTF_MAGNIFICATION = 423;  /// < Magnification used for CTF-determination
   public static final int RLN_CTF_MAXRES = 424;  /// < Maximum resolution with Thon rings
   public static final int RLN_CTF_CONVERGENCE_CONE = 425;  /// < Convergence cone
   public static final int RLN_CTF_LONGITUDINAL_DISPLACEMENT = 426;  /// < Longitudinal displacement
   public static final int RLN_CTF_TRANSVERSAL_DISPLACEMENT = 427;  /// < Transversal displacemente
   public static final int RLN_CTF_Q0 = 428;  /// < Amplitude contrast
   public static final int RLN_CTF_K = 429;  /// < CTF gain
   public static final int RLN_CTF_VALUE = 430;  /// < CTF value
   public static final int RLN_CTF_VALIDATIONSCORE = 431;  /// < Gctf-based validation score for CTF fit
   public static final int RLN_CTF_PHASESHIFT = 432;  /// < Phase-shift from a phase-plate (in degrees)
   public static final int RLN_IMAGE_NAME = 433; /// 
   public static final int RLN_IMAGE_RECONSTRUCT_NAME = 434; /// 
   public static final int RLN_IMAGE_ID = 435; /// 
   public static final int RLN_IMAGE_ENABLED = 436; /// 
   public static final int RLN_IMAGE_DATATYPE = 437; /// 
   public static final int RLN_IMAGE_DIMENSIONALITY = 438; /// 
   public static final int RLN_IMAGE_BEAMTILT_X = 439; /// 
   public static final int RLN_IMAGE_BEAMTILT_Y = 440; /// 
   public static final int RLN_IMAGE_BEAMTILT_GROUP = 441; /// 
   public static final int RLN_IMAGE_COORD_X = 442; /// 
   public static final int RLN_IMAGE_COORD_Y = 443; /// 
   public static final int RLN_IMAGE_COORD_Z = 444; /// 
   public static final int RLN_IMAGE_FRAME_NR = 445; /// 
   public static final int RLN_IMAGE_MAGNIFICATION_CORRECTION = 446; /// 
   public static final int RLN_IMAGE_NORM_CORRECTION = 447; /// 
   public static final int RLN_IMAGE_ORI_NAME = 448; /// 
   public static final int RLN_IMAGE_SAMPLINGRATE = 449; /// 
   public static final int RLN_IMAGE_SAMPLINGRATE_X = 450; /// 
   public static final int RLN_IMAGE_SAMPLINGRATE_Y = 451; /// 
   public static final int RLN_IMAGE_SAMPLINGRATE_Z = 452; /// 
   public static final int RLN_IMAGE_SIZE = 453; /// 
   public static final int RLN_IMAGE_SIZEX = 454; /// 
   public static final int RLN_IMAGE_SIZEY = 455; /// 
   public static final int RLN_IMAGE_SIZEZ = 456; /// 
   public static final int RLN_IMAGE_STATS_MIN = 457; /// 
   public static final int RLN_IMAGE_STATS_MAX = 458; /// 
   public static final int RLN_IMAGE_STATS_AVG = 459; /// 
   public static final int RLN_IMAGE_STATS_STDDEV = 460; /// 
   public static final int RLN_IMAGE_STATS_SKEW = 461; /// 
   public static final int RLN_IMAGE_STATS_KURT = 462; /// 
   public static final int RLN_IMAGE_WEIGHT = 463; /// 
   public static final int RLN_MASK_NAME = 464; /// 
   public static final int RLN_MATRIX_1_1 = 465; /// 
   public static final int RLN_MATRIX_1_2 = 466; /// 
   public static final int RLN_MATRIX_1_3 = 467; /// 
   public static final int RLN_MATRIX_2_1 = 468; /// 
   public static final int RLN_MATRIX_2_2 = 469; /// 
   public static final int RLN_MATRIX_2_3 = 470; /// 
   public static final int RLN_MATRIX_3_1 = 471; /// 
   public static final int RLN_MATRIX_3_2 = 472; /// 
   public static final int RLN_MATRIX_3_3 = 473; /// 
   public static final int RLN_MICROGRAPH_ID = 474; /// 
   public static final int RLN_MICROGRAPH_MOVIE_NAME = 475; /// 
   public static final int RLN_MICROGRAPH_NAME = 476; /// 
   public static final int RLN_MICROGRAPH_NAME_WODOSE = 477; /// 
   public static final int RLN_MICROGRAPH_TILT_ANGLE = 478; /// 
   public static final int RLN_MICROGRAPH_TILT_AXIS_DIRECTION = 479; /// 
   public static final int RLN_MICROGRAPH_TILT_AXIS_OUTOFPLANE = 480; /// 
   public static final int RLN_MLMODEL_ACCURACY_ROT = 481; /// 
   public static final int RLN_MLMODEL_ACCURACY_TRANS = 482; /// 
   public static final int RLN_MLMODEL_AVE_PMAX = 483; /// 
   public static final int RLN_MLMODEL_CURRENT_RESOLUTION = 484; /// 
   public static final int RLN_MLMODEL_CURRENT_SIZE = 485; /// 
   public static final int RLN_MLMODEL_DATA_VS_PRIOR_REF = 486; /// 
   public static final int RLN_MLMODEL_DIMENSIONALITY = 487; /// 
   public static final int RLN_MLMODEL_DIMENSIONALITY_DATA = 488; /// 
   public static final int RLN_MLMODEL_DIFF2_HALVES_REF = 489; /// 
   public static final int RLN_MLMODEL_ESTIM_RESOL_REF = 490; /// 
   public static final int RLN_MLMODEL_FOURIER_COVERAGE_REF = 491; /// 
   public static final int RLN_MLMODEL_FOURIER_COVERAGE_TOTAL_REF = 492; /// 
   public static final int RLN_MLMODEL_FSC_HALVES_REF = 493; /// 
   public static final int RLN_MLMODEL_GROUP_NAME = 494; /// 
   public static final int RLN_MLMODEL_GROUP_NO = 495; /// 
   public static final int RLN_MLMODEL_GROUP_NR_PARTICLES = 496; /// 
   public static final int RLN_MLMODEL_GROUP_SCALE_CORRECTION = 497; /// 
   public static final int RLN_MLMODEL_HELICAL_NR_ASU = 498; /// 
   public static final int RLN_MLMODEL_HELICAL_TWIST = 499; /// 
   public static final int RLN_MLMODEL_HELICAL_TWIST_MIN = 500; /// 
   public static final int RLN_MLMODEL_HELICAL_TWIST_MAX = 501; /// 
   public static final int RLN_MLMODEL_HELICAL_TWIST_INITIAL_STEP = 502; /// 
   public static final int RLN_MLMODEL_HELICAL_RISE = 503; /// 
   public static final int RLN_MLMODEL_HELICAL_RISE_MIN = 504; /// 
   public static final int RLN_MLMODEL_HELICAL_RISE_MAX = 505; /// 
   public static final int RLN_MLMODEL_HELICAL_RISE_INITIAL_STEP = 506; /// 
   public static final int RLN_MLMODEL_IS_HELIX = 507; /// 
   public static final int RLN_MLMODEL_INTERPOLATOR = 508; /// 
   public static final int RLN_MLMODEL_LL = 509; /// 
   public static final int RLN_MLMODEL_MINIMUM_RADIUS_NN_INTERPOLATION = 510; /// 
   public static final int RLN_MLMODEL_NORM_CORRECTION_AVG = 511; /// 
   public static final int RLN_MLMODEL_NR_BODIES = 512; /// 
   public static final int RLN_MLMODEL_NR_CLASSES = 513; /// 
   public static final int RLN_MLMODEL_NR_GROUPS = 514; /// 
   public static final int RLN_MLMODEL_ORIGINAL_SIZE = 515; /// 
   public static final int RLN_MLMODEL_ORIENTABILITY_CONTRIBUTION = 516; /// 
   public static final int RLN_MLMODEL_PADDING_FACTOR = 517; /// 
   public static final int RLN_MLMODEL_PDF_CLASS = 518; /// 
   public static final int RLN_MLMODEL_PRIOR_OFFX_CLASS = 519; /// 
   public static final int RLN_MLMODEL_PRIOR_OFFY_CLASS = 520; /// 
   public static final int RLN_MLMODEL_PDF_ORIENT = 521; /// 
   public static final int RLN_MLMODEL_PIXEL_SIZE = 522; /// 
   public static final int RLN_MLMODEL_POWER_REF = 523; /// 
   public static final int RLN_MLMODEL_PRIOR_MODE = 524; /// 
   public static final int RLN_MLMODEL_SGD_GRADIENT_IMAGE = 525; /// 
   public static final int RLN_MLMODEL_SIGMA_OFFSET = 526; /// 
   public static final int RLN_MLMODEL_SIGMA_ROT = 527; /// 
   public static final int RLN_MLMODEL_SIGMA_TILT = 528; /// 
   public static final int RLN_MLMODEL_SIGMA_PSI = 529; /// 
   public static final int RLN_MLMODEL_REF_IMAGE = 530; /// 
   public static final int RLN_MLMODEL_SIGMA2_NOISE = 531; /// 
   public static final int RLN_MLMODEL_SIGMA2_REF = 532; /// 
   public static final int RLN_MLMODEL_SSNR_REF = 533; /// 
   public static final int RLN_MLMODEL_TAU2_FUDGE_FACTOR = 534; /// 
   public static final int RLN_MLMODEL_TAU2_REF = 535; /// 
   public static final int RLN_OPTIMISER_ACCURACY_ROT = 536; /// 
   public static final int RLN_OPTIMISER_ACCURACY_TRANS = 537; /// 
   public static final int RLN_OPTIMISER_ADAPTIVE_FRACTION = 538; /// 
   public static final int RLN_OPTIMISER_ADAPTIVE_OVERSAMPLING = 539; /// 
   public static final int RLN_OPTIMISER_AUTO_LOCAL_HP_ORDER = 540; /// 
   public static final int RLN_OPTIMISER_AVAILABLE_MEMORY = 541; /// 
   public static final int RLN_OPTIMISER_BEST_RESOL_THUS_FAR = 542; /// 
   public static final int RLN_OPTIMISER_CHANGES_OPTIMAL_OFFSETS = 543; /// 
   public static final int RLN_OPTIMISER_CHANGES_OPTIMAL_ORIENTS = 544; /// 
   public static final int RLN_OPTIMISER_CHANGES_OPTIMAL_CLASSES = 545; /// 
   public static final int RLN_OPTIMISER_COARSE_SIZE = 546; /// 
   public static final int RLN_OPTIMISER_DATA_ARE_CTF_PHASE_FLIPPED = 547; /// 
   public static final int RLN_OPTIMISER_DATA_ARE_CTF_PREMULTIPLIED = 548; /// 
   public static final int RLN_OPTIMISER_DATA_STARFILE = 549; /// 
   public static final int RLN_OPTIMISER_DO_AUTO_REFINE = 550; /// 
   public static final int RLN_OPTIMISER_DO_ONLY_FLIP_CTF_PHASES = 551; /// 
   public static final int RLN_OPTIMISER_DO_CORRECT_CTF = 552; /// 
   public static final int RLN_OPTIMISER_DO_CORRECT_MAGNIFICATION = 553; /// 
   public static final int RLN_OPTIMISER_DO_CORRECT_NORM = 554; /// 
   public static final int RLN_OPTIMISER_DO_CORRECT_SCALE = 555; /// 
   public static final int RLN_OPTIMISER_DO_HELICAL_REFINE = 556; /// 
   public static final int RLN_OPTIMISER_DO_REALIGN_MOVIES = 557; /// 
   public static final int RLN_OPTIMISER_DO_MAP = 558; /// 
   public static final int RLN_OPTIMISER_DO_SGD = 559; /// 
   public static final int RLN_OPTIMISER_DO_SOLVENT_FLATTEN = 560; /// 
   public static final int RLN_OPTIMISER_DO_SKIP_ALIGN = 561; /// 
   public static final int RLN_OPTIMISER_DO_SKIP_ROTATE = 562; /// 
   public static final int RLN_OPTIMISER_DO_SPLIT_RANDOM_HALVES = 563; /// 
   public static final int RLN_OPTIMISER_DO_ZERO_MASK = 564; /// 
   public static final int RLN_OPTIMISER_FIX_SIGMA_NOISE = 565; /// 
   public static final int RLN_OPTIMISER_FIX_SIGMA_OFFSET = 566; /// 
   public static final int RLN_OPTIMISER_FIX_TAU = 567; /// 
   public static final int RLN_OPTIMISER_HAS_CONVERGED = 568; /// 
   public static final int RLN_OPTIMISER_HAS_HIGH_FSC_AT_LIMIT = 569; /// 
   public static final int RLN_OPTIMISER_HAS_LARGE_INCR_SIZE_ITER_AGO = 570; /// 
   public static final int RLN_OPTIMISER_HELICAL_TWIST_INITIAL = 571; /// 
   public static final int RLN_OPTIMISER_HELICAL_RISE_INITIAL = 572; /// 
   public static final int RLN_OPTIMISER_HELICAL_Z_PERCENTAGE = 573; /// 
   public static final int RLN_OPTIMISER_HELICAL_TUBE_INNER_DIAMETER = 574; /// 
   public static final int RLN_OPTIMISER_HELICAL_TUBE_OUTER_DIAMETER = 575; /// 
   public static final int RLN_OPTIMISER_HELICAL_SYMMETRY_LOCAL_REFINEMENT = 576; /// 
   public static final int RLN_OPTIMISER_HELICAL_SIGMA_DISTANCE = 577; /// 
   public static final int RLN_OPTIMISER_HIGHRES_LIMIT_SGD = 578; /// 
   public static final int RLN_OPTIMISER_IGNORE_HELICAL_SYMMETRY = 579; /// 
   public static final int RLN_OPTIMISER_HELICAL_KEEP_TILT_PRIOR_FIXED = 580; /// 
   public static final int RLN_OPTIMISER_HIGHRES_LIMIT_EXP = 581; /// 
   public static final int RLN_OPTIMISER_IGNORE_CTF_UNTIL_FIRST_PEAK = 582; /// 
   public static final int RLN_OPTIMISER_INCR_SIZE = 583; /// 
   public static final int RLN_OPTIMISER_ITERATION_NO = 584; /// 
   public static final int RLN_OPTIMISER_LOCAL_SYMMETRY_FILENAME = 585; /// 
   public static final int RLN_OPTIMISER_LOWRES_JOIN_RANDOM_HALVES = 586; /// 
   public static final int RLN_OPTIMISER_MAGNIFICATION_RANGE = 587; /// 
   public static final int RLN_OPTIMISER_MAGNIFICATION_STEP = 588; /// 
   public static final int RLN_OPTIMISER_MAX_COARSE_SIZE = 589; /// 
   public static final int RLN_OPTIMISER_MAX_NR_POOL = 590; /// 
   public static final int RLN_OPTIMISER_MODEL_STARFILE = 591; /// 
   public static final int RLN_OPTIMISER_MODEL_STARFILE2 = 592; /// 
   public static final int RLN_OPTIMISER_NR_ITERATIONS = 593; /// 
   public static final int RLN_OPTIMISER_NR_ITER_WO_RESOL_GAIN = 594; /// 
   public static final int RLN_OPTIMISER_NR_ITER_WO_HIDDEN_VAR_CHANGES = 595; /// 
   public static final int RLN_OPTIMISER_OUTPUT_ROOTNAME = 596; /// 
   public static final int RLN_OPTIMISER_PARTICLE_DIAMETER = 597; /// 
   public static final int RLN_OPTIMISER_RADIUS_MASK_3D_MAP = 598; /// 
   public static final int RLN_OPTIMISER_RADIUS_MASK_EXP_PARTICLES = 599; /// 
   public static final int RLN_OPTIMISER_RANDOM_SEED = 600; /// 
   public static final int RLN_OPTIMISER_REFS_ARE_CTF_CORRECTED = 601; /// 
   public static final int RLN_OPTIMISER_SAMPLING_STARFILE = 602; /// 
   public static final int RLN_OPTIMISER_SGD_MU = 603; /// 
   public static final int RLN_OPTIMISER_SGD_SIGMA2FUDGE_INI = 604; /// 
   public static final int RLN_OPTIMISER_SGD_SIGMA2FUDGE_HALFLIFE = 605; /// 
   public static final int RLN_OPTIMISER_SGD_SUBSET_START = 606; /// 
   public static final int RLN_OPTIMISER_SGD_SUBSET_SIZE = 607; /// 
   public static final int RLN_OPTIMISER_SGD_WRITE_EVERY_SUBSET = 608; /// 
   public static final int RLN_OPTIMISER_SGD_MAX_SUBSETS = 609; /// 
   public static final int RLN_OPTIMISER_SGD_STEPSIZE = 610; /// 
   public static final int RLN_OPTIMISER_SMALLEST_CHANGES_OPT_CLASSES = 611; /// 
   public static final int RLN_OPTIMISER_SMALLEST_CHANGES_OPT_OFFSETS = 612; /// 
   public static final int RLN_OPTIMISER_SMALLEST_CHANGES_OPT_ORIENTS = 613; /// 
   public static final int RLN_OPTIMISER_SOLVENT_MASK_NAME = 614; /// 
   public static final int RLN_OPTIMISER_SOLVENT_MASK2_NAME = 615; /// 
   public static final int RLN_OPTIMISER_TAU_SPECTRUM_NAME = 616; /// 
   public static final int RLN_OPTIMISER_USE_TOO_COARSE_SAMPLING = 617; /// 
   public static final int RLN_OPTIMISER_WIDTH_MASK_EDGE = 618; /// 
   public static final int RLN_ORIENT_FLIP = 619; /// 
   public static final int RLN_ORIENT_ID = 620; /// 
   public static final int RLN_ORIENT_ORIGIN_X = 621; /// 
   public static final int RLN_ORIENT_ORIGIN_X_PRIOR = 622; /// 
   public static final int RLN_ORIENT_ORIGIN_Y = 623; /// 
   public static final int RLN_ORIENT_ORIGIN_Y_PRIOR = 624; /// 
   public static final int RLN_ORIENT_ORIGIN_Z = 625; /// 
   public static final int RLN_ORIENT_ORIGIN_Z_PRIOR = 626; /// 
   public static final int RLN_ORIENT_ROT = 627; /// 
   public static final int RLN_ORIENT_ROT_PRIOR = 628; /// 
   public static final int RLN_ORIENT_TILT = 629; /// 
   public static final int RLN_ORIENT_TILT_PRIOR = 630; /// 
   public static final int RLN_ORIENT_PSI = 631; /// 
   public static final int RLN_ORIENT_PSI_PRIOR = 632; /// 
   public static final int RLN_ORIENT_PSI_PRIOR_FLIP_RATIO = 633; /// 
   public static final int RLN_PARTICLE_AUTOPICK_FOM = 634; /// 
   public static final int RLN_PARTICLE_CLASS = 635; /// 
   public static final int RLN_PARTICLE_DLL = 636; /// 
   public static final int RLN_PARTICLE_ID = 637; /// 
   public static final int RLN_PARTICLE_FOM = 638; /// 
   public static final int RLN_PARTICLE_KL_DIVERGENCE = 639; /// 
   public static final int RLN_PARTICLE_MOVIE_RUNNING_AVG = 640; /// 
   public static final int RLN_PARTICLE_RANDOM_SUBSET = 641; /// 
   public static final int RLN_PARTICLE_NAME = 642; /// 
   public static final int RLN_PARTICLE_ORI_NAME = 643; /// 
   public static final int RLN_PARTICLE_NR_SIGNIFICANT_SAMPLES = 644; /// 
   public static final int RLN_PARTICLE_NR_FRAMES = 645; /// 
   public static final int RLN_PARTICLE_NR_FRAMES_AVG = 646; /// 
   public static final int RLN_PARTICLE_PMAX = 647; /// 
   public static final int RLN_PARTICLE_HELICAL_TUBE_ID = 648; /// 
   public static final int RLN_PARTICLE_HELICAL_TUBE_PITCH = 649; /// 
   public static final int RLN_PARTICLE_HELICAL_TRACK_LENGTH = 650; /// 
   public static final int RLN_PIPELINE_JOB_COUNTER = 651; /// 
   public static final int RLN_PIPELINE_NODE_NAME = 652; /// 
   public static final int RLN_PIPELINE_NODE_TYPE = 653; /// 
   public static final int RLN_PIPELINE_PROCESS_ALIAS = 654; /// 
   public static final int RLN_PIPELINE_PROCESS_NAME = 655; /// 
   public static final int RLN_PIPELINE_PROCESS_TYPE = 656; /// 
   public static final int RLN_PIPELINE_PROCESS_STATUS = 657; /// 
   public static final int RLN_PIPELINE_EDGE_FROM = 658; /// 
   public static final int RLN_PIPELINE_EDGE_TO = 659; /// 
   public static final int RLN_PIPELINE_EDGE_PROCESS = 660; /// 
   public static final int RLN_POSTPROCESS_AMPLCORR_MASKED = 661; /// 
   public static final int RLN_POSTPROCESS_AMPLCORR_UNMASKED = 662; /// 
   public static final int RLN_POSTPROCESS_BFACTOR = 663; /// 
   public static final int RLN_POSTPROCESS_DPR_MASKED = 664; /// 
   public static final int RLN_POSTPROCESS_DPR_UNMASKED = 665; /// 
   public static final int RLN_POSTPROCESS_FINAL_RESOLUTION = 666; /// 
   public static final int RLN_POSTPROCESS_FSC_GENERAL = 667; /// 
   public static final int RLN_POSTPROCESS_FSC_TRUE = 668; /// 
   public static final int RLN_POSTPROCESS_FSC_MASKED = 669; /// 
   public static final int RLN_POSTPROCESS_FSC_UNMASKED = 670; /// 
   public static final int RLN_POSTPROCESS_FSC_RANDOM_MASKED = 671; /// 
   public static final int RLN_POSTPROCESS_GUINIER_FIT_CORRELATION = 672; /// 
   public static final int RLN_POSTPROCESS_GUINIER_FIT_INTERCEPT = 673; /// 
   public static final int RLN_POSTPROCESS_GUINIER_FIT_SLOPE = 674; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_IN = 675; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_INVMTF = 676; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_WEIGHTED = 677; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_SHARPENED = 678; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_INTERCEPT = 679; /// 
   public static final int RLN_POSTPROCESS_GUINIER_RESOL_SQUARED = 680; /// 
   public static final int RLN_POSTPROCESS_MTF_VALUE = 681;  /// < Detector MTF value
   public static final int RLN_SAMPLING_IS_3D = 682; /// 
   public static final int RLN_SAMPLING_IS_3D_TRANS = 683; /// 
   public static final int RLN_SAMPLING_HEALPIX_ORDER = 684; /// 
   public static final int RLN_SAMPLING_HELICAL_OFFSET_STEP = 685; /// 
   public static final int RLN_SAMPLING_LIMIT_TILT = 686; /// 
   public static final int RLN_SAMPLING_OFFSET_RANGE = 687; /// 
   public static final int RLN_SAMPLING_OFFSET_STEP = 688; /// 
   public static final int RLN_SAMPLING_PERTURB = 689; /// 
   public static final int RLN_SAMPLING_PERTURBATION_FACTOR = 690; /// 
   public static final int RLN_SAMPLING_PRIOR_MODE = 691; /// 
   public static final int RLN_SAMPLING_PSI_STEP = 692; /// 
   public static final int RLN_SAMPLING_SIGMA_ROT = 693; /// 
   public static final int RLN_SAMPLING_SIGMA_TILT = 694; /// 
   public static final int RLN_SAMPLING_SIGMA_PSI = 695; /// 
   public static final int RLN_SAMPLING_SYMMETRY = 696; /// 
   public static final int RLN_SELECTED = 697; /// 
   public static final int RLN_SELECT_PARTICLES_ZSCORE = 698; /// 
   public static final int RLN_SORTED_IDX = 699; /// 
   public static final int RLN_STARFILE_MOVIE_PARTICLES = 700; /// 
   public static final int RLN_PERFRAME_CUMULATIVE_WEIGHT = 701; /// 
   public static final int RLN_PERFRAME_RELATIVE_WEIGHT = 702; /// 
   public static final int RLN_RESOLUTION = 703; /// 
   public static final int RLN_RESOLUTION_ANGSTROM = 704; /// 
   public static final int RLN_RESOLUTION_INVPIXEL = 705; /// 
   public static final int RLN_SPECTRAL_IDX = 706; /// 
   public static final int MDL_LAST_LABEL = 707;  // **** NOTE ****: Do keep this label always at the end;it is here for looping purposes /// 
}
