/***************************************************************************
 *
 * Authors:     Jose Luis Vilas (jlvilas@cnb.csic.es)
 *              Hemant. D. Tagare
 *
 * Unidad de  Bioinformatica of Centro Nacional de Biotecnologia , CSIC
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307  USA
 *
 *  All comments concerning this program package may be sent to the
 *  e-mail address 'xmipp@cnb.csic.es'
 ***************************************************************************/

#include <core/xmipp_program.h>
#include <core/xmipp_fftw.h>
#include <core/metadata_extension.h>
#include <data/monogenic.h>
#include <ctime>

class ProgResolutionDirectionalFsc : public XmippProgram
{
public:

    FileName    fnhalf1, fnhalf2, fnmask, fn_root, fn_out;
    double      sampling, max_sam, min_sam;
    bool        do_dpr = false, do_rfactor = false, test;

    Matrix2D<double> angles;
    FileName    fn_sel;

    void defineParams()
    {
        addUsageLine("Calculate the directional FSC resolution of two half maps along a set of directions");
        addUsageLine("+ ");
        addUsageLine("+* Fourier Ring Correlation (FRC)", true);
        addUsageLine("+This program may then be used to calculate FSC between these two volumes. The resulting plots");
        addUsageLine("+are commonly used to assess the high-resolution limit of the initial reconstruction.");
        addUsageLine(" ");
        addUsageLine("The program writes out filename.frc files, for each input volume or image, or selfilename.frc, the");
        addUsageLine("set_of_images mode. These ACSII files contain the DPR, FRC and SSNR as a function of resolution (in 1/Angstrom).");
        addUsageLine(" The .frc files also contain a column for the FRC expected for pure noise.");
        addSeeAlsoLine("resolution_ssnr");

        addParamsLine("   --half1 <input_file>      : Half map1");
        addParamsLine("   --half2 <input_file>      : Half map2");
        addParamsLine("   [--mask <input_file=\"\">]     : (Optional) Smooth mask to remove noise");
        addParamsLine("   [-o <output_file=\"\">]   : Output file name.");
        addParamsLine("   [--test]                  : It executes an unitary test");

        addParamsLine("   [--sampling_rate <Ts=1>]  : Pixel size (Angstrom)");
        addParamsLine("   [--max_sam <max_sr=-1>]   : set fsc to 0 for frequencies above this one (Angstrom), -1 -> all fequencies");
        addParamsLine("                             : --max_sam = 10A -> frequencies higher than 0.1 A^-1 =0");

        addExampleLine("Resolution of subset2.vol volume with respect to subset1.vol reference volume using 5.6 pixel size (in Angstrom):", false);
        addExampleLine("xmipp_resolution_fsc --ref subset1.vol  -i subset2.vol --sampling_rate 5.6 ");
        addExampleLine("Resolution of a set of images using 5.6 pixel size (in Angstrom):", false);
        addExampleLine("xmipp_resolution_fsc --set_of_images selfile.sel --sampling_rate 5.6");
    }

    void readParams()
    {
        sampling = getDoubleParam("--sampling_rate");
        max_sam = getDoubleParam("--max_sam");
        min_sam = -1;

        fnhalf1 = getParam("--half1");
        fnhalf2 = getParam("--half2");
        fnmask = getParam("--mask");
        fn_out = getParam("-o");
        test = checkParam("--test");
    }

    void defineFrequencies(MultidimArray<double> &vol,
    		MultidimArray<std::complex<double>> &fftvol,
    		MultidimArray<double> &freq, Matrix1D<double> &freq_fourier_vec)
    {
    	// Frequency volume
    	double uz, uy, ux, uz2, u2, uz2y2;
    	long n=0;

    	freq.resizeNoCopy(fftvol);

    	for(size_t k=0; k<ZSIZE(fftvol); ++k)
    	{
    		FFT_IDX2DIGFREQ(k,ZSIZE(vol),uz);
    		uz2=uz*uz;

    		for(size_t i=0; i<YSIZE(fftvol); ++i)
    		{
    			FFT_IDX2DIGFREQ(i,YSIZE(vol),uy);
    			uz2y2=uz2+uy*uy;

    			for(size_t j=0; j<XSIZE(fftvol); ++j)
    			{
    				FFT_IDX2DIGFREQ(j,XSIZE(vol), ux);
    				u2=uz2y2+ux*ux;
    				DIRECT_MULTIDIM_ELEM(freq,n) = sqrt(u2);
    				++n;
    			}
    		}
    	}

    	double u;
    	size_t dimfft, dimreal;

    	if (XSIZE(fftvol) <= YSIZE(fftvol))
    		if (XSIZE(fftvol) <= ZSIZE(fftvol)){
    			dimfft = XSIZE(fftvol);
    			dimreal = XSIZE(vol);
    		}

    	if (YSIZE(fftvol) <= XSIZE(fftvol))
    		if (YSIZE(fftvol) <= ZSIZE(fftvol)){
    			dimfft = YSIZE(fftvol);
    			dimreal = YSIZE(vol);
    		}

    	if (ZSIZE(fftvol) <= XSIZE(fftvol))
    		if (ZSIZE(fftvol) <= YSIZE(fftvol)){
    			dimfft = ZSIZE(fftvol);
    			dimreal = ZSIZE(vol);
    		}

    	freq_fourier_vec.initZeros(dimfft);

    	VEC_ELEM(freq_fourier_vec,0) = 1e-38;
    	for(size_t k=1; k<dimfft; ++k){
    		FFT_IDX2DIGFREQ(k,dimreal, u);
    		VEC_ELEM(freq_fourier_vec,k) = u;
    	}



    }
    MultidimArray<double> defineFrequencies(const MultidimArray< std::complex<double> > &myfftV,
    		const MultidimArray<double> &inputVol,
    		Matrix1D<double> &freq_fourier_x,
    		Matrix1D<double> &freq_fourier_y,
    		Matrix1D<double> &freq_fourier_z)
    {
    	double u;

    	freq_fourier_z.initZeros(ZSIZE(myfftV));
    	freq_fourier_x.initZeros(XSIZE(myfftV));
    	freq_fourier_y.initZeros(YSIZE(myfftV));

    	VEC_ELEM(freq_fourier_z,0) = 1e-38;
    	for(size_t k=1; k<ZSIZE(myfftV); ++k){
    		FFT_IDX2DIGFREQ(k,ZSIZE(inputVol), u);
    		VEC_ELEM(freq_fourier_z,k) = u;
    	}

    	VEC_ELEM(freq_fourier_y,0) = 1e-38;
    	for(size_t k=1; k<YSIZE(myfftV); ++k){
    		FFT_IDX2DIGFREQ(k,YSIZE(inputVol), u);
    		VEC_ELEM(freq_fourier_y,k) = u;
    	}

    	VEC_ELEM(freq_fourier_x,0) = 1e-38;
    	for(size_t k=1; k<XSIZE(myfftV); ++k){
    		FFT_IDX2DIGFREQ(k,XSIZE(inputVol), u);
    		VEC_ELEM(freq_fourier_x,k) = u;
    	}


    	MultidimArray<double> iu;

    	iu.initZeros(myfftV);

    	double uz, uy, ux, uz2, u2, uz2y2;
    	long n=0;
    	//  TODO: reasign uz = uz*uz to save memory
    	//  TODO: Take ZSIZE(myfftV) out of the loop
    	//	TODO: Use freq_fourier_x instead of calling FFT_IDX2DIGFREQ

    	for(size_t k=0; k<ZSIZE(myfftV); ++k)
    	{
    		FFT_IDX2DIGFREQ(k,ZSIZE(inputVol),uz);
    		uz2 = uz*uz;
    		for(size_t i=0; i<YSIZE(myfftV); ++i)
    		{
    			FFT_IDX2DIGFREQ(i,YSIZE(inputVol),uy);
    			uz2y2 = uz2 + uy*uy;

    			for(size_t j=0; j<XSIZE(myfftV); ++j)
    			{
    				FFT_IDX2DIGFREQ(j,XSIZE(inputVol), ux);
    				u2 = uz2y2 + ux*ux;
   					DIRECT_MULTIDIM_ELEM(iu,n) = sqrt(u2);
    				++n;
    			}
    		}
    	}


    	return iu;
    }
    void writeFiles(const FileName &fnRoot,
                    const MultidimArray<double> &freq,
                    const MultidimArray<double> &frc,
                    const MultidimArray<double> &frc_noise,
                    const MultidimArray<double> &dpr,
                    const MultidimArray<double> &error_l2,
					double max_sam, bool do_dpr, double rFactor)
    {
        MetaData MD;

        FileName  fn_frc;
        fn_frc = fn_out;

        size_t id;
        FOR_ALL_ELEMENTS_IN_ARRAY1D(freq)
        {
            if (i>0)
            {
                id=MD.addObject();
                if(max_sam >0 && ((1./dAi(freq, i))<max_sam) )
                {
                    if(do_dpr)
                        dAi(dpr, i)=0.;
                    dAi(frc, i)=0.;
                }
                if(min_sam >0 && ((1./dAi(freq, i))>min_sam) )
                {
                	if(do_dpr)
                        dAi(dpr, i)=0.;
                    dAi(frc, i)=0.;
                }
                MD.setValue(MDL_RESOLUTION_FREQ,dAi(freq, i),id);
                MD.setValue(MDL_RESOLUTION_FRC,dAi(frc, i),id);
                if(do_dpr)
                    MD.setValue(MDL_RESOLUTION_DPR,dAi(dpr, i),id);
                MD.setValue(MDL_RESOLUTION_ERRORL2,dAi(error_l2, i),id);
                MD.setValue(MDL_RESOLUTION_FRCRANDOMNOISE,dAi(frc_noise, i),id);
                MD.setValue(MDL_RESOLUTION_FREQREAL,1./dAi(freq, i),id);
            }
        }
        MD.write(fn_frc);
        MetaData MD2;
        MD2.setColumnFormat(false);
        id=MD2.addObject();
        MD2.setValue(MDL_RESOLUTION_RFACTOR,rFactor,id);
        fn_frc.compose("rfactor", fn_frc);
        MD2.write(fn_frc, MD_APPEND);
    }

    void fscDir(MultidimArray< std::complex< double > > & FT1,
            	 MultidimArray< std::complex< double > > & FT2,
                 double sampling_rate,
				 Matrix1D<double> &freq_fourier_x,
				 Matrix1D<double> &freq_fourier_y,
				 Matrix1D<double> &freq_fourier_z,
                 MultidimArray< double >& freq,
                 MultidimArray< double >& frc,
    			 double maxFreq, int m1sizeX, int m1sizeY, int m1sizeZ)
    {
        MultidimArray< int > radial_count(m1sizeX/2+1);
        MultidimArray<double> num, den1, den2;
        Matrix1D<double> f(3);

        num.initZeros(radial_count);
        den1.initZeros(radial_count);
        den2.initZeros(radial_count);

        freq.initZeros(radial_count);
        frc.initZeros(radial_count);

        int sizeZ_2 = m1sizeZ/2;
        if (sizeZ_2==0)
            sizeZ_2=1;
        double isizeZ = 1.0/m1sizeZ;
        int sizeY_2 = m1sizeY/2;
        double iysize = 1.0/m1sizeY;
        int sizeX_2 = m1sizeX/2;
        double ixsize = 1.0/m1sizeX;
        double R;

        int ZdimFT1=(int)ZSIZE(FT1);
        int YdimFT1=(int)YSIZE(FT1);
        int XdimFT1=(int)XSIZE(FT1);

        double maxFreq_2 =0.;
        maxFreq_2 = maxFreq * maxFreq;

        double ux, uy, uz;
        for (int k=0; k<ZdimFT1; k++)
        {
            double uz = VEC_ELEM(freq_fourier_z,k);
//            FFT_IDX2DIGFREQ_FAST(k,m1sizeZ,sizeZ_2,isizeZ,uz);
//            double fz2=ZZ(f)*ZZ(f);
            double fz2=uz*uz;
            for (int i=0; i<YdimFT1; i++)
            {
            	double uy = VEC_ELEM(freq_fourier_y,i);
//            	FFT_IDX2DIGFREQ(i,m1sizeY, uy);
                double fz2_fy2=fz2 + uy*uy;
                for (int j=0; j<XdimFT1; j++)
                {
                	double ux = VEC_ELEM(freq_fourier_x,j);
//                	FFT_IDX2DIGFREQ_FAST(j,m1sizeZ,sizeZ_2,isizeZ,ux);
                    double R2 =fz2_fy2 + ux*ux;
                    if (R2>maxFreq_2)
                        continue;

                    R = sqrt(R2);
                    int idx = (int)round(R * m1sizeX);
                    std::complex<double> &z1 = dAkij(FT1, k, i, j);
                    std::complex<double> &z2 = dAkij(FT2, k, i, j);
                    double absz1 = abs(z1);
                    double absz2 = abs(z2);
                    dAi(num,idx) += real(conj(z1) * z2);
                    dAi(den1,idx) += absz1*absz1;
                    dAi(den2,idx) += absz2*absz2;
                }
            }
        }

        FOR_ALL_ELEMENTS_IN_ARRAY1D(freq)
        {
            dAi(freq,i) = (double) i / (m1sizeX * sampling_rate);
            dAi(frc,i) = dAi(num,i)/sqrt(dAi(den1,i)*dAi(den2,i));
        }
    }

    void dirFilter(const MultidimArray< std::complex<double> > &FT1,
    		const MultidimArray< std::complex<double> > &FT2,
    		MultidimArray< std::complex<double> > &FT1_dir,
			MultidimArray< std::complex<double> > &FT2_dir,
    		Matrix1D<double> &freq_fourier_x,
			Matrix1D<double> &freq_fourier_y,
			Matrix1D<double> &freq_fourier_z,
    		MultidimArray<double> &freq,  double rot, double tilt,
    		double ang_con)
    {
    //	conefilter.initZeros(myfftV);
    	FT1_dir = FT1;
    	FT2_dir = FT2;
    	// Filter the input volume and add it to amplitude

//    	MultidimArray<double> conetest;
//    	conetest.initZeros(FT1);

    	double x_dir, y_dir, z_dir, uz, uy, ux;
    	x_dir = sin(tilt*PI/180)*cos(rot*PI/180);
    	y_dir = sin(tilt*PI/180)*sin(rot*PI/180);
    	z_dir = cos(tilt*PI/180);

    	long n = 0;
    	double aa;
    	for(size_t k=0; k<ZSIZE(FT1); ++k)
    	{
    		uz = VEC_ELEM(freq_fourier_z,k);
    		uz *= z_dir;
    		for(size_t i=0; i<YSIZE(FT1); ++i)
    		{
    			uy = VEC_ELEM(freq_fourier_y,i);
    			uy *= y_dir;
    			for(size_t j=0; j<XSIZE(FT1); ++j)
    			{
    				double iun = 1.0/DIRECT_MULTIDIM_ELEM(freq,n);
    				ux = VEC_ELEM(freq_fourier_x,j);
    				ux *= x_dir;

    				iun *= (ux + uy + uz);
    				double acosine = acos(fabs(iun));
    				if (acosine>ang_con)
    				{
    					DIRECT_MULTIDIM_ELEM(FT1_dir, n) = 0;
    					DIRECT_MULTIDIM_ELEM(FT2_dir, n) = 0;
    				}
    				++n;
    			}
    		}
    	}
//    	Image<double> saveImg2;
//    	saveImg2() = conetest;
//    	saveImg2.write("cono.vol");
    }

    bool process_sel()
    {
        MetaData MD(fn_sel), MDout;
        MultidimArray<double> freq, frc, dpr, frc_noise, ssnr, error_l2;
        getFourierStatistics(MD, sampling, MDout, do_dpr, max_sam);
        FileName fnRoot=(fn_root.empty())?fn_sel:fn_root;
        MDout.write(fnRoot+".frc");
        return true;
    }

    void generateDirections(Matrix2D<double> &angles)
    {
    	//TODO: use coordinates on the sphere instead of angles
    	angles.initZeros(2,81);
    	MAT_ELEM(angles, 0, 0) = 0.000000;	 	 MAT_ELEM(angles, 1, 0) = 0.000000;
    	MAT_ELEM(angles, 0, 1) = 36.000000;	 	 MAT_ELEM(angles, 1, 1) = 15.858741;
    	MAT_ELEM(angles, 0, 2) = 36.000000;	 	 MAT_ELEM(angles, 1, 2) = 31.717482;
    	MAT_ELEM(angles, 0, 3) = 36.000000;	 	 MAT_ELEM(angles, 1, 3) = 47.576224;
    	MAT_ELEM(angles, 0, 4) = 36.000000;	 	 MAT_ELEM(angles, 1, 4) = 63.434965;
    	MAT_ELEM(angles, 0, 5) = 62.494295;	 	 MAT_ELEM(angles, 1, 5) = -76.558393;
    	MAT_ELEM(angles, 0, 6) = 54.000000;	 	 MAT_ELEM(angles, 1, 6) = 90.000000;
    	MAT_ELEM(angles, 0, 7) = 45.505705;	 	 MAT_ELEM(angles, 1, 7) = 76.558393;
    	MAT_ELEM(angles, 0, 8) = 108.000000;	 MAT_ELEM(angles, 1, 8) = 15.858741;
    	MAT_ELEM(angles, 0, 9) = 108.000000;	 MAT_ELEM(angles, 1, 9) = 31.717482;
    	MAT_ELEM(angles, 0, 10) = 108.000000;	 MAT_ELEM(angles, 1, 10) = 47.576224;
    	MAT_ELEM(angles, 0, 11) = 108.000000;	 MAT_ELEM(angles, 1, 11) = 63.434965;
    	MAT_ELEM(angles, 0, 12) = 134.494295;	 MAT_ELEM(angles, 1, 12) = -76.558393;
    	MAT_ELEM(angles, 0, 13) = 126.000000;	 MAT_ELEM(angles, 1, 13) = 90.000000;
    	MAT_ELEM(angles, 0, 14) = 117.505705;	 MAT_ELEM(angles, 1, 14) = 76.558393;
    	MAT_ELEM(angles, 0, 15) = 144.000000;	 MAT_ELEM(angles, 1, 15) = -15.858741;
    	MAT_ELEM(angles, 0, 16) = 144.000000;	 MAT_ELEM(angles, 1, 16) = -31.717482;
    	MAT_ELEM(angles, 0, 17) = 144.000000;	 MAT_ELEM(angles, 1, 17) = -47.576224;
    	MAT_ELEM(angles, 0, 18) = 144.000000;	 MAT_ELEM(angles, 1, 18) = -63.434965;
    	MAT_ELEM(angles, 0, 19) = 170.494295;	 MAT_ELEM(angles, 1, 19) = 76.558393;
    	MAT_ELEM(angles, 0, 20) = 162.000000;	 MAT_ELEM(angles, 1, 20) = 90.000000;
    	MAT_ELEM(angles, 0, 21) = 153.505705;	 MAT_ELEM(angles, 1, 21) = -76.558393;
    	MAT_ELEM(angles, 0, 22) = 72.000000;	 MAT_ELEM(angles, 1, 22) = -15.858741;
    	MAT_ELEM(angles, 0, 23) = 72.000000;	 MAT_ELEM(angles, 1, 23) = -31.717482;
    	MAT_ELEM(angles, 0, 24) = 72.000000;	 MAT_ELEM(angles, 1, 24) = -47.576224;
    	MAT_ELEM(angles, 0, 25) = 72.000000;	 MAT_ELEM(angles, 1, 25) = -63.434965;
    	MAT_ELEM(angles, 0, 26) = 98.494295;	 MAT_ELEM(angles, 1, 26) = 76.558393;
    	MAT_ELEM(angles, 0, 27) = 90.000000;	 MAT_ELEM(angles, 1, 27) = 90.000000;
    	MAT_ELEM(angles, 0, 28) = 81.505705;	 MAT_ELEM(angles, 1, 28) = -76.558393;
    	MAT_ELEM(angles, 0, 29) = 0.000000;	 	 MAT_ELEM(angles, 1, 29) = -15.858741;
    	MAT_ELEM(angles, 0, 30) = 0.000000;	 	 MAT_ELEM(angles, 1, 30) = -31.717482;
    	MAT_ELEM(angles, 0, 31) = 0.000000;	 	 MAT_ELEM(angles, 1, 31) = -47.576224;
    	MAT_ELEM(angles, 0, 32) = 0.000000;	 	 MAT_ELEM(angles, 1, 32) = -63.434965;
    	MAT_ELEM(angles, 0, 33) = 26.494295;	 MAT_ELEM(angles, 1, 33) = 76.558393;
    	MAT_ELEM(angles, 0, 34) = 18.000000;	 MAT_ELEM(angles, 1, 34) = 90.000000;
    	MAT_ELEM(angles, 0, 35) = 9.505705;	 	 MAT_ELEM(angles, 1, 35) = -76.558393;
    	MAT_ELEM(angles, 0, 36) = 12.811021;	 MAT_ELEM(angles, 1, 36) = 42.234673;
    	MAT_ELEM(angles, 0, 37) = 18.466996;	 MAT_ELEM(angles, 1, 37) = 59.620797;
    	MAT_ELEM(angles, 0, 38) = 0.000000;	 	 MAT_ELEM(angles, 1, 38) = 90.000000;
    	MAT_ELEM(angles, 0, 39) = 8.867209;	 	 MAT_ELEM(angles, 1, 39) = 75.219088;
    	MAT_ELEM(angles, 0, 40) = 72.000000;	 MAT_ELEM(angles, 1, 40) = 26.565058;
    	MAT_ELEM(angles, 0, 41) = 59.188979;	 MAT_ELEM(angles, 1, 41) = 42.234673;
    	MAT_ELEM(angles, 0, 42) = 84.811021;	 MAT_ELEM(angles, 1, 42) = 42.234673;
    	MAT_ELEM(angles, 0, 43) = 53.533003;	 MAT_ELEM(angles, 1, 43) = 59.620797;
    	MAT_ELEM(angles, 0, 44) = 72.000000;	 MAT_ELEM(angles, 1, 44) = 58.282544;
    	MAT_ELEM(angles, 0, 45) = 90.466996;	 MAT_ELEM(angles, 1, 45) = 59.620797;
    	MAT_ELEM(angles, 0, 46) = 72.000000;	 MAT_ELEM(angles, 1, 46) = 90.000000;
    	MAT_ELEM(angles, 0, 47) = 63.132791;	 MAT_ELEM(angles, 1, 47) = 75.219088;
    	MAT_ELEM(angles, 0, 48) = 80.867209;	 MAT_ELEM(angles, 1, 48) = 75.219088;
    	MAT_ELEM(angles, 0, 49) = 144.000000;	 MAT_ELEM(angles, 1, 49) = 26.565058;
    	MAT_ELEM(angles, 0, 50) = 131.188979;	 MAT_ELEM(angles, 1, 50) = 42.234673;
    	MAT_ELEM(angles, 0, 51) = 156.811021;	 MAT_ELEM(angles, 1, 51) = 42.234673;
    	MAT_ELEM(angles, 0, 52) = 125.533003;	 MAT_ELEM(angles, 1, 52) = 59.620797;
    	MAT_ELEM(angles, 0, 53) = 144.000000;	 MAT_ELEM(angles, 1, 53) = 58.282544;
    	MAT_ELEM(angles, 0, 54) = 162.466996;	 MAT_ELEM(angles, 1, 54) = 59.620797;
    	MAT_ELEM(angles, 0, 55) = 144.000000;	 MAT_ELEM(angles, 1, 55) = 90.000000;
    	MAT_ELEM(angles, 0, 56) = 135.132791;	 MAT_ELEM(angles, 1, 56) = 75.219088;
    	MAT_ELEM(angles, 0, 57) = 152.867209;	 MAT_ELEM(angles, 1, 57) = 75.219088;
    	MAT_ELEM(angles, 0, 58) = 180.000000;	 MAT_ELEM(angles, 1, 58) = -26.565058;
    	MAT_ELEM(angles, 0, 59) = 167.188979;	 MAT_ELEM(angles, 1, 59) = -42.234673;
    	MAT_ELEM(angles, 0, 60) = 180.000000;	 MAT_ELEM(angles, 1, 60) = -58.282544;
    	MAT_ELEM(angles, 0, 61) = 161.533003;	 MAT_ELEM(angles, 1, 61) = -59.620797;
    	MAT_ELEM(angles, 0, 62) = 171.132791;	 MAT_ELEM(angles, 1, 62) = -75.219088;
    	MAT_ELEM(angles, 0, 63) = 108.000000;	 MAT_ELEM(angles, 1, 63) = -26.565058;
    	MAT_ELEM(angles, 0, 64) = 120.811021;	 MAT_ELEM(angles, 1, 64) = -42.234673;
    	MAT_ELEM(angles, 0, 65) = 95.188979;	 MAT_ELEM(angles, 1, 65) = -42.234673;
    	MAT_ELEM(angles, 0, 66) = 126.466996;	 MAT_ELEM(angles, 1, 66) = -59.620797;
    	MAT_ELEM(angles, 0, 67) = 108.000000;	 MAT_ELEM(angles, 1, 67) = -58.282544;
    	MAT_ELEM(angles, 0, 68) = 89.533003;	 MAT_ELEM(angles, 1, 68) = -59.620797;
    	MAT_ELEM(angles, 0, 69) = 108.000000;	 MAT_ELEM(angles, 1, 69) = 90.000000;
    	MAT_ELEM(angles, 0, 70) = 116.867209;	 MAT_ELEM(angles, 1, 70) = -75.219088;
    	MAT_ELEM(angles, 0, 71) = 99.132791;	 MAT_ELEM(angles, 1, 71) = -75.219088;
    	MAT_ELEM(angles, 0, 72) = 36.000000;	 MAT_ELEM(angles, 1, 72) = -26.565058;
    	MAT_ELEM(angles, 0, 73) = 48.811021;	 MAT_ELEM(angles, 1, 73) = -42.234673;
    	MAT_ELEM(angles, 0, 74) = 23.188979;	 MAT_ELEM(angles, 1, 74) = -42.234673;
    	MAT_ELEM(angles, 0, 75) = 54.466996;	 MAT_ELEM(angles, 1, 75) = -59.620797;
    	MAT_ELEM(angles, 0, 76) = 36.000000;	 MAT_ELEM(angles, 1, 76) = -58.282544;
    	MAT_ELEM(angles, 0, 77) = 17.533003;	 MAT_ELEM(angles, 1, 77) = -59.620797;
    	MAT_ELEM(angles, 0, 78) = 36.000000;	 MAT_ELEM(angles, 1, 78) = 90.000000;
    	MAT_ELEM(angles, 0, 79) = 44.867209;	 MAT_ELEM(angles, 1, 79) = -75.219088;
    	MAT_ELEM(angles, 0, 80) = 27.132791;	 MAT_ELEM(angles, 1, 80) = -75.219088;
    }


//    void FSCinterpolation(const Matrix2D<double> &fsc, const Matrix2D<double> &angles,
//    		MultidimArray<double> &threeD_FSC)
//    {
//    	std::cout << "Obtaining 3D FSC" << std::endl;
//    	double x_dir, y_dir, z_dir, uz, uy, ux, tilt, rot;
//
//
//    	std::vector<double> distances;
//    	FOR_ALL_DIRECT_ELEMENTS_IN_ARRAY3D(threeD_FSC)
//		{
//    		for (size_t d=0; d<angles.mdim; d++)
//			{
//    			double rot = MAT_ELEM(angles, 0, k);
//    			double tilt = MAT_ELEM(angles, 1, k);
//    			x_dir = sin(tilt*PI/180)*cos(rot*PI/180);
//				y_dir = sin(tilt*PI/180)*sin(rot*PI/180);
//				z_dir = cos(tilt*PI/180);
//
//				double r = sqrt(k*k + i*i + j*j);
//				double acosine = (x_dir*k + y_dir*i + x_dir*j)/r;
//				distances.push_back();
//			}
//		}
//
//    }


    void fftshift(MultidimArray<double> &vol, MultidimArray<double> &shiftedVol)
    {
    	std::cout << "applying shift in Fourier" << std::endl;

    	int xdim = XSIZE(vol), ydim = YSIZE(vol), zdim = ZSIZE(vol);

    	shiftedVol.resizeNoCopy(vol);

    	FOR_ALL_ELEMENTS_IN_ARRAY3D(shiftedVol)
			A3D_ELEM(shiftedVol, (k+zdim/2)%zdim, (i+ydim/2)%ydim, j) = A3D_ELEM(vol, k, i, j);

    }

    void fullFourierSpace(MultidimArray<double> & origMap,
    					  MultidimArray<double> & fullMap,
						  int xdim, int ydim, int zdim)
    {
    	fullMap.resize(1, zdim, ydim, xdim, false);

        double *ptrSource=NULL;
        double *ptrDest=NULL;
        FOR_ALL_DIRECT_ELEMENTS_IN_ARRAY3D(fullMap)
			{
				ptrDest=(double*)&DIRECT_A3D_ELEM(fullMap,k,i,j);
				if (j<xdim)
				{
					ptrSource=(double*)&DIRECT_A3D_ELEM(origMap,k,i,j);
					*ptrDest=*ptrSource;
					*(ptrDest+1)=*(ptrSource+1);
				}
				else
				{
					ptrSource=(double*)&DIRECT_A3D_ELEM(fullMap,
														(zdim-k)%zdim,
														(ydim-i)%ydim,
														xdim-j);
					*ptrDest=*ptrSource;
					*(ptrDest+1)=-(*(ptrSource+1));
				}
			}
    }

    void ShiftFFT_bis(MultidimArray<double> & v,
                  double xshift, double yshift, double zshift)
    {
        v.checkDimension(3);
        double dotp, a, b, c, d, ac, bd, ab_cd;
        double xxshift = -2 * PI * xshift / (double)XSIZE(v);
        double yyshift = -2 * PI * yshift / (double)YSIZE(v);
        double zzshift = -2 * PI * zshift / (double)ZSIZE(v);
        for (size_t k=0; k<ZSIZE(v); ++k)
        {
        	double zdot=(double)(k) * zzshift;
            for (size_t i=0; i<YSIZE(v); ++i)
            {
            	double zydot=zdot+(double)(i) * yyshift;
                for (size_t j=0; j<XSIZE(v); ++j)
                {
                	double *ptrv_kij=(double *)&DIRECT_A3D_ELEM(v,k,i,j);
                    dotp = (double)(j) * xxshift + zydot;
                    sincos(dotp,&b,&a);
                    c = *ptrv_kij;
                    d = *(ptrv_kij+1);
                    ac = a * c;
                    bd = b * d;
                    ab_cd = (a + b) * (c + d);
                    *ptrv_kij = ac - bd;
                    *(ptrv_kij+1) = ab_cd - ac - bd;
                }
            }
        }
    }



    void run()
    {
    	std::cout << "Starting..." << std::endl;
    	Image<double> half1, half2, mask;
    	MultidimArray<double> &phalf1 = half1(), &phalf2 = half2(), &pmask = mask();
    	MultidimArray< std::complex< double > > FT1, FT2, FT1_dir, FT2_dir;

    	if (test)
    	{
    		Monogenic mono;
    		std::cout << "Preparing test data ..." << std::endl;
    		size_t xdim = 301, ydim = 301, zdim = 301;
    		double wavelength = 5.0, mean = 0.0, std = 0.5;
    		int maskrad = 125;
    		half1() = mono.createDataTest(xdim, ydim, zdim, wavelength, mean, 0.0);
    		half2() = half1();

    		mono.addNoise(half1(), 0, std);
    		mono.addNoise(half2(), 0, std);
    		FileName fn;
    		Image<double> saveImg;
    		fn = formatString("inputVol1_large.vol");
    		saveImg = half1;
    		saveImg.write(fn);
    		fn = formatString("inputVol2_large.vol");
    		saveImg = half2;
    		saveImg.write(fn);
    		std::cout << "Start ..." << std::endl;
    	}
    	else
    	{
    		std::cout << "Reading data..." << std::endl;
    		half1.read(fnhalf1);
    		half2.read(fnhalf2);

    		if (fnmask!="")
    		{
    			mask.read(fnmask);
				FOR_ALL_DIRECT_ELEMENTS_IN_MULTIDIMARRAY(pmask)
				{
					double valmask = (double) DIRECT_MULTIDIM_ELEM(pmask, n);
					DIRECT_MULTIDIM_ELEM(phalf1, n) = DIRECT_MULTIDIM_ELEM(phalf1, n) * valmask;
					DIRECT_MULTIDIM_ELEM(phalf2, n) = DIRECT_MULTIDIM_ELEM(phalf2, n) * valmask;
				}
    		}
    		mask.clear();
    		pmask.clear();
    	}
    	unsigned t0, t1;
    	t0=clock();

		phalf1.setXmippOrigin();
		phalf2.setXmippOrigin();


		//Defining Fourier transform
        FourierTransformer transformer2(FFTW_BACKWARD), transformer1(FFTW_BACKWARD);
        transformer1.FourierTransform(phalf1, FT1, false);
        transformer2.FourierTransform(phalf2, FT2, false);

        int m1sizeX = XSIZE(phalf1), m1sizeY = YSIZE(phalf1), m1sizeZ = ZSIZE(phalf1);

        Matrix1D<double> freq_fourier_x, freq_fourier_y, freq_fourier_z;
        MultidimArray<double> freqMap, freqMapFull, freqMapFullshift;

        freqMap = defineFrequencies(FT1, phalf1,
        		freq_fourier_x,freq_fourier_y, freq_fourier_z);


//        	bool forward = true;
//        double xshift = -(double)(int)(XSIZE(freqMap) / 2);
//                double yshift = -(double)(int)(YSIZE(freqMap) / 2);
//                double zshift = -(double)(int)(ZSIZE(freqMap) / 2);
//                if (forward)
//                {
//                	ShiftFFT_bis(freqMap, xshift, yshift, zshift);
//                    CenterFFT(freqMap, forward);
//                }
//                else
//                {
//                    CenterFFT(freqMap, forward);
//                    ShiftFFT_bis(freqMap, -xshift, -yshift, -zshift);
//                }
//
//
//        fullFourierSpace(freqMap, freqMapFull,
//								  m1sizeX, m1sizeY, m1sizeZ);
//        CenterFFT(freqMapFull, true);
//        freqMapFull.setXmippOrigin();

//    	Image<double> saveImg2;
//    	saveImg2() = freqMapFull;
//    	saveImg2.write("aaaa.vol");

//    	fftshift(freqMapFull, freqMapFullshift);
//
//
//    	saveImg2() = freqMapFullshift;
//    	saveImg2.write("bbbb.vol");
////        defineFrequencies(phalf1, FT1, freqMap, freq_fourier_vec);
//    	exit(0);


        phalf2.clear(); // Free memory
        phalf1.clear(); // Free memory


    	Matrix2D<double> FSC;
    	MultidimArray<double> fsc, freq;
    	double ang_con = 20*PI/180;
    	generateDirections(angles);

    	for (size_t k = 0; k<angles.mdimx; k++)
			{
			double rot = MAT_ELEM(angles, 0, k);
			double tilt = MAT_ELEM(angles, 1, k);

//			dirFilter(FT1, FT2, FT1_dir, FT2_dir,
//					freq_fourier_x, freq_fourier_y, freq_fourier_z, freqMap, rot, tilt, ang_con);

			fscDir(FT1, FT2, sampling, freq_fourier_x, freq_fourier_y, freq_fourier_z, freq, fsc, 0.5, m1sizeX, m1sizeY, m1sizeZ);
			std::cout << "------------------------------" <<  std::endl;
			FOR_ALL_ELEMENTS_IN_ARRAY1D(fsc)
				std::cout << dAi(freq, i) << "     " << dAi(fsc,i) << ";" << std::endl;

    	}
        t1 = clock();

        double time = (double(t1-t0)/CLOCKS_PER_SEC);
        std::cout << "Execution Time: " << time << std::endl;
    }

};
